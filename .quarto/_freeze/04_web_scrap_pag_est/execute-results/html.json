{
  "hash": "0e8c2f2aa7df28884ff12ac9289ec77e",
  "result": {
    "engine": "knitr",
    "markdown": "# Bases para el \"raspado web\" (*web scraping*) en páginas estáticas.\n\n## Archivos HTML (HyperText Markup Language)\n\n<font style=\"color:darkcyan;\">Una página web es un archivo de texto plano que utiliza la extensión \".html\"</font> (Riva Quiroga, 2022).\n\nAl contenido de ese archivo se le agregan ciertas etiquetas para indicar a qué corresponde cada uno de sus elementos, lo que permite darle la estructura necesaria para que se visualice correctamente en un navegador.\n\nEjemplo:\n\n``` markdown\n<html>\n\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Título</title>\n</head>\n\n<body>\n  <h1 id='primero'>Título</h1>\n  <p>Texto.; <b>Texto en negrita.</b></p>\n  </body>\n  \n</html>\n \n```\n\nHTML tiene una estructura jerárquica formada por **elementos** que consisten en una etiqueta de inicio (por ejemplo <tag>), opcional **atributos** (id='primero'), una etiqueta final (como </tag>), y **contenido** (todo entre la etiqueta de inicio y final).\n\n::: {style=\"border-radius: 20px; overflow: auto; width: 70%; margin: 0 auto; justify-content: center\"}\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Fuente: https://developer.mozilla.org/es/docs/Web/HTML](elemento.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n\n:::\n\nLas partes principales del elemento son:\n\n-   <font style=\"color:darkcyan;\">La etiqueta de apertura</font>: consiste en el nombre del elemento (en este caso, p), encerrado por paréntesis angulares (\\< \\>) de apertura y cierre. Establece dónde comienza o empieza a tener efecto el elemento —en este caso, dónde es el comienzo del párrafo—.\n\n-   <font style=\"color:darkcyan;\">La etiqueta de cierre</font>: es igual que la etiqueta de apertura, excepto que incluye una barra de cierre (/) antes del nombre de la etiqueta. Establece dónde termina el elemento —en este caso dónde termina el párrafo—.\n\n-   <font style=\"color:darkcyan;\">El contenido</font>: este es el contenido del elemento, que en este caso es sólo texto.\n\n-   <font style=\"color:darkcyan;\">El elemento</font>: la etiqueta de apertura, más la etiqueta de cierre, más el contenido equivale al elemento.\n\nHay más de 100 elementos HTML. Algunos de los más importantes son:\n\n-   Cada página HTML debe estar en un elemento <font style=\"color:darkcyan;\">`<html>`</font>, y debe tener dos **hijos**: <font style=\"color:darkcyan;\">`<head>`</font>, que contiene metadatos de documentos como el título de la página, y <font style=\"color:darkcyan;\">`<body>`</font>, que contiene el contenido que ve en el navegador.\n\n``` markdown\n<p>\n  Hola! Mi <b>nombre</b> es Juan.\n</p>\n```\n\nLos **hijos (children)** son los elementos contenidos dentro de otros elementos. El elemento `<p>` de arriba tiene un hijo, el elemento `<b>`. El elemento `<b>` no tiene hijos, pero sí tiene contenido (el texto \"nombre\").\n\n-   Etiquetas de **bloques** como <font style=\"color:darkcyan;\">`<h1>`</font>, <font style=\"color:darkcyan;\">`<section>`</font> (sección), <font style=\"color:darkcyan;\">`<p>`</font> (párrafo), y <font style=\"color:darkcyan;\">`<ol>`</font> (lista ordenada) forman la estructura general de la página.\n\n-   Etiquetas en línea como <font style=\"color:darkcyan;\">`<b>`</font> (negrita), <font style=\"color:darkcyan;\">`<i>`</font> (itálica), y <font style=\"color:darkcyan;\">`<a>`</font> (enlace) dan formato al texto dentro de las etiquetas de bloque.\n\nLos elementos pueden tener <font style=\"color:darkcyan;\">atributos</font>:\n\n``` markdown\n<p class = \"clase_1\"> Párrafo.</p>\n```\n\nLos atributos contienen información adicional sobre el elemento que no aparecerá en el contenido. En este ejemplo, el atributo *class* es un atributo de identificación de referencia a determinadas propiedades.\n\n*Ejemplo*:\n\n``` markdown\n\n<html>\n\n<head>\n<style>\nh1.estilo1 {\n    color: blue;\n}\np.estilo2 {\n    color: red\n}\n</style>\n</head>\n\n<body>\n\n<h1 class = \"estilo1\">Encabezado</h1>\n<p class = \"estilo2\">Primer párrafo.</p>\n<p>Segundo párrafo.</p>\n\n</body>\n</html>\n```\n\n| Atributo | Descripción | Etiquetas |\n|---------------|--------------------------------|-------------------------|\n| id | Identificador único para un elemento | Todas |\n| class | Especifica una o más clases CSS para un elemento | Todas |\n| src | Especifica la URL de un recurso externo, como imágenes o scripts | \\<img\\>, \\<script\\>, \\<iframe\\>, \\<audio\\>, \\<video\\> |\n| href | Define la URL de un enlace | \\<a\\>, \\<link\\> |\n| alt | Texto alternativo para imágenes | \\<img\\>, \\<area\\> |\n| title | Texto emergente cuando el usuario pasa el cursor sobre un elemento | Todas |\n| style | Define estilos CSS en línea | Todas |\n| disabled | Deshabilita un elemento de entrada | \\<button\\>, \\<input\\>, \\<select\\>, \\<textarea\\> |\n| placeholder | Texto de sugerencia en campos de entrada | \\<input\\>, \\<textarea\\> |\n| readonly | Hace que un campo de entrada sea de solo lectura | \\<input\\>, \\<textarea\\> |\n| required | Indica que un campo de entrada es obligatorio | \\<input\\>, \\<select\\>, \\<textarea\\> |\n| type | Define el tipo de entrada | \\<input\\> |\n| value | Especifica el valor de un elemento de entrada | \\<input\\>, \\<option\\>, \\<button\\> |\n| name | Nombre del elemento para envío en formularios | \\<input\\>, \\<textarea\\>, \\<select\\>, \\<form\\> |\n\n::: callout-tip\n###### Tip\n\nUn recurso de consulta recomendado es [MDN Web Doc](https://developer.mozilla.org/en-US/docs/Web/HTML)\n:::\n\n## Extracción de datos\n\nEste apartado es una adaptación de la Unidad 24 del libro [R for Data Science](https://r4ds.hadley.nz/webscraping).\n\nEn **R**, el acceso a la información provista desde páginas estáticas puede realizarse utilizando funciones de la librería **{rvest}**, que puede ser instalada desde el CRAN:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instalación de {rvest} (debe realizarse sólo una vez)\n\ninstall.packages(\"rvest\")\n```\n:::\n\n\n\n\n\n\nLuego, toda vez que deseemos utilizar la librería **{rvest}**, deberemos invocarla por medio de la función **library()**:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"rvest\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml_cn_22 = read_html(\"https://censo.gob.ar/index.php/datos_definitivos/\")\nhtml_cn_22\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{html_document}\n<html class=\"html\" lang=\"es-AR\">\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8 ...\n[2] <body class=\"page-template-default page page-id-37582 wp-custom-logo wp-e ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: callout-note\n**{rvest}** incluye la función *minimal_html()* que permite escribir html, que utilizaremos para ilustrar el modo de funcionamiento con ejemplo simples.\n:::\n\nPor Ejemplo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = minimal_html(\n  \"\n  <p>Esto es un párrafo</p>\n  <ul>\n    <li>Esto es una lista</li>\n  </ul>\n  \"\n)\nhtml\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{html_document}\n<html>\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8 ...\n[2] <body>\\n<p>Esto es un párrafo</p>\\n  <ul>\\n<li>Esto es una lista</li>\\n   ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Encontrar elementos\n\nCSS (cascading style sheets) define patrones para localizar elementos html, útiles para \"rascar\" datos web. Por ejemplo:\n\n-   `p` selecciona todos los elementos **p**.\n\n-   `.title` selecciona todos los elementos con la `clase` \"title\".\n\n-   `#title` selecciona el elemento con el atributo `id` igual a \"title\".\n\nPor ejemplo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = minimal_html(\n  \"\n  <h>Esto es un encabezado</h>\n  <p id='primero'>Esto es un párrafo</p>\n  <p class='importante'>Esto es un párrafo importante</p>\n  \"\n)\nhtml\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{html_document}\n<html>\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8 ...\n[2] <body>\\n<p id=\"primero\">Esto es un párrafo</p>\\n  <p class=\"importante\">E ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa función **html_elements()** permite encontrar todos los elementos que coinciden con el selector:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml |> html_elements(\"p\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (2)}\n[1] <p id=\"primero\">Esto es un párrafo</p>\n[2] <p class=\"importante\">Esto es un párrafo importante</p>\n```\n\n\n:::\n\n```{.r .cell-code}\nhtml |> html_elements(\".importante\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (1)}\n[1] <p class=\"importante\">Esto es un párrafo importante</p>\n```\n\n\n:::\n\n```{.r .cell-code}\nhtml |> html_elements(\"#primero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (1)}\n[1] <p id=\"primero\">Esto es un párrafo</p>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**html_element()** devuelve el mismo número de salidas que las entradas. Si se aplica a un documento completo, devolverá la primera coincidencia:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml |> html_element(\"p\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{html_node}\n<p id=\"primero\">\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: callout-note\n## Nota\n\nCuando se utiliza un selector que no coincie con ningún elemento, html_elements() devuelve un vector de longitud 0, y html_element() devuelve un valor omitido (NA).\n\n:::\n\n\n## Selecciones anidadas\n\nEs posible combinar las funciones html_element() y html_elements(). Por ejemplo:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = minimal_html(\n  \"\n  <ul>\n    <li><b>Opción 1</b> es un ejemplo de <i>item</i> con una <span class='tipo'>característica 1</span></li>\n    <li><b>Opción 2</b> es otro ejemplo de  <i>item</i></li>\n    <li><b>Opción 3</b> es otro <i>item</i> con la característica <span class=tipo'>característica 3</span></li>\n  </ul>\n  \"\n)\n```\n:::\n\n\n\n\n\n\n- Selección de items:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopciones = html |> html_elements(\"li\")\nopciones\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (3)}\n[1] <li>\\n<b>Opción 1</b> es un ejemplo de <i>item</i> con una <span class=\"t ...\n[2] <li>\\n<b>Opción 2</b> es otro ejemplo de  <i>item</i>\\n</li>\n[3] <li>\\n<b>Opción 3</b> es otro <i>item</i> con la característica <span cla ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotar lo siguiente:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopciones |> html_element(\"b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (3)}\n[1] <b>Opción 1</b>\n[2] <b>Opción 2</b>\n[3] <b>Opción 3</b>\n```\n\n\n:::\n\n```{.r .cell-code}\nopciones |> html_element(\".tipo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (3)}\n[1] <span class=\"tipo\">característica 1</span>\n[2] <NA>\n[3] <NA>\n```\n\n\n:::\n\n```{.r .cell-code}\nopciones |> html_elements(\".tipo\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{xml_nodeset (1)}\n[1] <span class=\"tipo\">característica 1</span>\n```\n\n\n:::\n:::\n\n\n\n\n\n## Texto y atributos\n\nLa función **html_text2()** extrae el contenido en texto plano de un elemento html:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopciones |>\n  html_element(\"b\") |>\n  html_text2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Opción 1\" \"Opción 2\" \"Opción 3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nopciones |>\n  html_element(\".tipo\") |>\n  html_text2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"característica 1\" NA                 NA                \n```\n\n\n:::\n:::\n\n\n\n\n\n\nLa función **html_attr()** extrae datos desde los atributos:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = minimal_html(\"\n  <p><a href='https://es.wikipedia.org/wiki/INDEC'>cats</a></p>\n  <p><a href='https://es.wikipedia.org/wiki/Agencia_de_Acceso_a_la_Información_Pública_(Argentina)'>dogs</a></p>\n\")\n\nhtml |> \n  html_elements(\"p\") |> \n  html_element(\"a\") |> \n  html_attr(\"href\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"https://es.wikipedia.org/wiki/INDEC\"                                                 \n[2] \"https://es.wikipedia.org/wiki/Agencia_de_Acceso_a_la_Información_Pública_(Argentina)\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Tablas\n\nSi los datos están almacenados como una tabla html, la importación puede realizarse sin inconvenientes. Las tablas html se construyen con cuatro elementos: `<table>`, `<tr>` (table row), `<th>` (table heading) y `<td>` (table data). Por ejemplo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = minimal_html(\"\n  <table class='miTabla'>\n    <tr><th>x</th>   <th>y</th></tr>\n    <tr><td>1.5</td> <td>2.7</td></tr>\n    <tr><td>4.9</td> <td>1.3</td></tr>\n    <tr><td>7.2</td> <td>8.1</td></tr>\n  </table>\n  \")\n```\n:::\n\n\n\n\n\n\nLuego, para extraer la tabla:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml |> \n  html_element(\".miTabla\") |> \n  html_table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n      x     y\n  <dbl> <dbl>\n1   1.5   2.7\n2   4.9   1.3\n3   7.2   8.1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Elección del selector adecuado\n\nUsualmente la elección del selector adecuado es la parte más complicada del proceso. Un selector adecuado debe ser `específico` y `sensible`.\n\nExisten dos herramientas que pueden facilitar la elección del selector adecuado:\n\n- `SelectorGadget`: es una extensión javascript que genera selectores CCS.\n\n- `Herramientas del motor de búsqueda`: seleccionar un objeto y, luego de hacer *click derecho*, seleccionar `inspeccionar`. Se desplegará una ventana con la estructura html de la página, centrada en el objeto seleccionado.\n\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n<iframe src=\"https://censo.gob.ar/index.php/datos_definitivos_jujuy/\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n:::\n\n\n\n\n\n\nPor ejemplo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml = read_html(\"https://censo.gob.ar/index.php/datos_definitivos_jujuy/\")\n\n# Exploración de \"hijos\" (children)\n\nhtml |> html_children()\n\nhtml |> html_element(\"body\") |> html_children()\n\n# Exploración de todos los enlaces\n\nenlace = html |>\n  html_elements(\"a\") |>\n  html_attr(\"href\")\n\n# Exploración de los enlaces de archivos en excel\n\nenlace[grepl(pattern = \".xlsx\",\n             enlace, \n             ignore.case = TRUE)]\n\n# Exploración de un nodo con un enlace específico (copiado el selector)\nhtml |>\n  html_element(\"#elementor-tab-content-1341 > p:nth-child(2) > span:nth-child(1) > a\")\n\n\n# Enlace a un archivo\n\nenlace = html |>\n  html_element(\"#elementor-tab-content-1341 > p:nth-child(2) > span:nth-child(1) > a\") |>\n  html_attr(\"href\")\n\nenlace\n  \n\n# Descarga de un archivo\n\narchivo_temp = tempfile(fileext = \".xlsx\")\narchivo_temp\n\ndownload.file(enlace, destfile = archivo_temp, mode = \"wb\")\n```\n:::\n\n\n\n\n\n\n\n\n## Librería `polite`\n\nLa librería **\\{polite\\}** tiene como objetivo promover un \"raspado\" web responsable. Las dos funciones principales del paquete, `bow` y `scrape`, definen y llevan a cabo una sesión de recolección de datos web. `bow` se utiliza para presentar al cliente al host y solicitar permiso para extraer datos (mediante una consulta en el archivo robots.txt del host), mientras que `scrape` es la función principal para recuperar datos del servidor remoto. Una vez que se establece la conexión, no es necesario volver a usar `bow` . En cambio, para ajustar una URL de extracción de datos, el usuario puede simplemente indicar la nueva ruta, que actualiza la URL de la sesión, asegurándose de que la nueva ubicación se pueda negociar en robots.txt.\n\nSe puede instalar `polite` desde el **CRAN** (una sola vez):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"polite\")\n```\n:::\n\n\n\n\n\n\nLuego\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(polite)\nsesion = bow(\"https://www.indec.gob.ar/\", force=TRUE)\n\nprint(sesion)\n\n# Título\n\ntitulo = scrape(sesion) %>%\n  html_node(\"title\") %>%\n  html_text()\n\nprint(titulo)\n\n# Enlaces\n\nenlaces = scrape(sesion) %>%\n  html_nodes(\"a\") %>%\n  html_attrs_dfr(\"href\")\n\nprint(enlaces)\n\nenlaces = scrape(sesion) %>%\n  html_nodes(\"a\") %>%\n  html_attrs_dfr(\"href\") |>\n  dplyr::filter(!is.na(href))\n\nprint(enlaces)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}